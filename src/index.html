<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Slenderman</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}

			#instructions {
				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;
				font-family: Arial;
				font-size: 14px;
				line-height: 24px;

				cursor: pointer;
			}

			#gameover {
				position: absolute;				
				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				text-align: center;
				font-family: Arial;
				font-size: 14px;
				line-height: 24px;

				visibility: hidden;			
			}
		</style>
	</head>
	<body>
		<div id="gameover">
			<br /><br />
			<span style="font-size:60px;color:#8d1212">Thank you for the pages</span>
		</div>
		<div id="blocker">
			<div id="instructions">
				<span style="font-size:40px;color:#8d1212">Collect the pages to escape</span>
				<br /><br />				
				<span style="font-size:30px">Click to play</span>
				<br /><br />
				<span style="font-size:20px">Move: WASD<br/>
				Look: MOUSE<br/>
				E: COLLECT PAGE<br/>
				Shift: RUN</span>
			</div>
		</div>

		<script src="js/three.js"></script>
		<script src="js/three.module.js"></script>
		<script src="js/PointerLockControls.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/EffectComposer.js"></script>
		<script src="js/ShaderPass.js"></script>
		<script src="js/CopyShader.js"></script>
		<script src="js/RenderPass.js"></script>
		<script src="js/GlitchPass.js"></script>
		<script src="js/DigitalGlitch.js"></script>

		<script type="module">
			(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()
			let camera, scene, renderer, controls, flashLight, spotLight1, spotLight2, spotLight3, spotLight4,slenderMan, origem, composer, glitchPass, onKeyDown, moveSpeed, rustedCar;

			const objects = [];

			let raycaster;

			let moveForward = false;
			let moveBackward = false;
			let moveLeft = false;
			let moveRight = false;
			let run = false;
			let interact = false;

			var trees = [];
			var papers = [];
			var slenders = [];
			let cameraBox, forestSound, stepSound, slenderStaticSound, pageFlipSound;
			var slenderSpeed = 0.0;
			var baseSlenderSpeed = 0;//0.0025;
			var collectPages = 0;

			var baseMoveSpeed = 5; //maior mais devagar
			var stamina = 100;

			// Save the current time
			let prevTime = performance.now();
			const velocity = new THREE.Vector3();
			const direction = new THREE.Vector3();
			const vertex = new THREE.Vector3();
			const color = new THREE.Color();

			var coordArray =
			[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
 			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
			[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
			[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 1],
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 1, 1, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1], 
			[1, 0, 2, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 20, 14, 0, 0, 0, 16, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], 
			[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], 
			[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], 
			[1, 1, 0, 0, 0, 23, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], 
			[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], 
			[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 0, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
			[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
			[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 0, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], 
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], 
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], 
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], 
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], 
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], 
			[1, 2, 3, 2, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
			[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],
			[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
			[0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
			[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
			[0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], 
			[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], 
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], 
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], 
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], 
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], 
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 99, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];
			// pages 6, 7, 8, 9, 10
			//55x43
			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.6, 1000 );
				camera.position.set(850, 10, 560);
				camera.rotation.y = -5;
				var cameraBox = new THREE.Box3().setFromObject( camera );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );
				scene.fog = new THREE.Fog( 0xffffff, 2, 0 );

				const light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.5 );  // ( 0xeeeeff, 0x777788, 0.5 )
				light.position.set( 0.5, 1, 0.75 );
				//scene.add(light);

				controls = new THREE.PointerLockControls( camera, document.body );

				const blocker = document.getElementById( 'blocker' );
				const instructions = document.getElementById( 'instructions' );
				const gameover = document.getElementById( 'gameover' );

				instructions.addEventListener( 'click', function () {

					controls.lock();

				}, false );

				controls.addEventListener( 'lock', function () {

					instructions.style.display = 'none';
					blocker.style.display = 'none';


					// create an AudioListener and add it to the camera
					const listener = new THREE.AudioListener();
					camera.add( listener );

					// create a global audio source
					forestSound = new THREE.Audio( listener );

					// load a sound and set it as the Audio object's buffer
					const AudioLoader = new THREE.AudioLoader();
					AudioLoader.load( 'sounds/forest.mp3', function( buffer ) {
						forestSound.setBuffer( buffer );
						forestSound.setLoop( true );
						forestSound.setVolume( 0.35 );
						forestSound.play();
					});

					// create a global audio source
					stepSound = new THREE.Audio( listener );
					slenderStaticSound = new THREE.Audio( listener );
					pageFlipSound = new THREE.Audio( listener );

					slenderSpeed = baseSlenderSpeed + collectPages*0.0025;

				} );

				controls.addEventListener( 'unlock', function () {

					blocker.style.display = 'block';
					instructions.style.display = '';
					slenderSpeed = 0;
					moveBackward, moveForward, moveLeft, moveRight = false;
					forestSound.stop();

				} );

				scene.add( controls.getObject() );

				onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 16: // shift
							run = true;
							break;

						case 69: // e
							interact = true;
							break;

					}

				};

				const onKeyUp = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

						case 16: // shift
							run = false;
							break;

						case 69: // e
							interact = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );
				

				( 'unlock', function () {

					blocker.style.display = 'block';
					instructions.style.display = '';
					forestSound.stop();

					} );				

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );	

				// floor

				let floorGeometry = new THREE.PlaneBufferGeometry( 1000, 1220, 100, 100 );
				floorGeometry.rotateX( - Math.PI / 2 );

				// vertex displacement

				let position = floorGeometry.attributes.position;

				for ( let i = 0, l = position.count; i < l; i ++ ) {

					vertex.fromBufferAttribute( position, i );

					vertex.x += Math.random() * 20 - 10;
					vertex.y += Math.random() * 2;
					vertex.z += Math.random() * 20 - 10;

					position.setXYZ( i, vertex.x, vertex.y, vertex.z );

				}

				// ensure each face has unique vertices
				floorGeometry = floorGeometry.toNonIndexed(); 

				const floor_texture = new THREE.TextureLoader().load( 'textures/grass1.jpg' );
				const floorMaterial = new THREE.MeshPhongMaterial( { map : floor_texture } );
				floor_texture.wrapS = THREE.RepeatWrapping;
				floor_texture.wrapT = THREE.RepeatWrapping;
				floor_texture.repeat.set( 12, 12 );				

				const floor = new THREE.Mesh( floorGeometry, floorMaterial );
				floor.position.x = 430;
				floor.position.z = 540;
				scene.add( floor );

				// objects


				for ( let i = 0; i < coordArray.length; i++) {
					var coordinates = coordArray[i]
					
					for(var j = 0; j < coordinates.length; j++) {
						if (coordinates[j] === 1) {
							const cylinderGeometry = new THREE.CylinderBufferGeometry( 10, 10, 200 ).toNonIndexed();
							const three_texture = new THREE.TextureLoader().load( 'textures/arvore.jpeg' );
							const cylinderMaterial = new THREE.MeshPhongMaterial( {  map : three_texture} );							
							const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );

							cylinder.position.x = i*20;
							cylinder.position.y = 95;
							cylinder.position.z = j*20;
							
							const box = new THREE.Box3();
							box.setFromObject(cylinder);

							//const helper = new THREE.Box3Helper( box, 0xffff00 );
							//scene.add( helper );

							scene.add( cylinder );
							objects.push( cylinder );
							trees.push( box );
						}
						else if (coordinates[j] === 2) {

							const containerLenght = 80;
							const containerHeight = 50;
							const planeGeometry = new THREE.PlaneGeometry( containerLenght, containerHeight)
							const container_texture = new THREE.TextureLoader().load( 'textures/container.png' );			
							const planeMaterial = new THREE.MeshPhongMaterial( {map: container_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 20;
							plane.position.z = j*20;

							const boxGeometry = new THREE.BoxGeometry( containerLenght, containerHeight, 2)		
							const collisionBox1 = new THREE.Mesh( boxGeometry);
							
							collisionBox1.position.x = i*20;
							collisionBox1.position.y = 20;
							collisionBox1.position.z = j*20;

							const box1 = new THREE.Box3();

							box1.setFromObject(collisionBox1);	

							scene.add( plane );	
							trees.push( box1 );						
						}

						else if (coordinates[j] === 3) {
							const planeGeometry = new THREE.PlaneGeometry( 80, 40)
							const container_texture = new THREE.TextureLoader().load( 'textures/container.png' );			
							const planeMaterial = new THREE.MeshPhongMaterial( {map: container_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 45;
							plane.position.z = j*20;
							plane.rotateX(Math.PI / 2)

							const box = new THREE.Box3();
							box.setFromObject(plane);

							scene.add( plane );						
						}

						else if (coordinates[j] === 4) {
							const boxGeometry = new THREE.BoxGeometry( 80, 40, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/wall.jpg' );			
							const boxMaterial = new THREE.MeshPhongMaterial( {map: wall_texture, side: THREE.DoubleSide} );
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20 - 20;
							box1.position.y = 20;
							box1.position.z = j*20;
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );					
						}

						else if (coordinates[j] === 5) {
							const boxGeometry = new THREE.BoxGeometry( 80, 40, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/wall.jpg' );			
							const boxMaterial = new THREE.MeshPhongMaterial( {map: wall_texture, side: THREE.DoubleSide} );
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20;
							box1.position.y = 20;
							box1.position.z = j*20;
							box1.rotateY(Math.PI / 2);
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 6) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader().load( 'textures/page1.jpeg' );
							const planeMaterial = new THREE.MeshPhongMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 2;
							plane.position.z = j*20;
							plane.rotateX(Math.PI*3/2);

							const box = new THREE.Box3();
							box.setFromObject(plane);


                            const helper = new THREE.Box3Helper( box, 0xFF0B0B );
							scene.add( helper );
							scene.add( plane );	
							papers.push(plane);
						}

						else if (coordinates[j] === 7) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader().load( 'textures/page2.jpeg' );
							paper_texture.roation = Math.PI/2
							const planeMaterial = new THREE.MeshPhongMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20-5;
							plane.position.y = 10;
							plane.position.z = j*20-18;
							plane.rotateX(Math.PI*2);

							const box = new THREE.Box3();
							box.setFromObject(plane);
							
                            const helper = new THREE.Box3Helper( box, 0xFF0B0B );
							scene.add( helper );
							scene.add( plane );	
							papers.push(plane);
						}			

						else if (coordinates[j] === 8) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader().load( 'textures/page3.jpeg' );			
							paper_texture.roation = Math.PI/2
							const planeMaterial = new THREE.MeshPhongMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20+10;
							plane.position.y = 8;
							plane.position.z = j*20+1.8;
							plane.rotateX(Math.PI*2);

							const box = new THREE.Box3();
							box.setFromObject(plane);

                            const helper = new THREE.Box3Helper( box, 0xFF0B0B );
							scene.add( helper );
							scene.add( plane );	
							papers.push(plane);
						}

						else if (coordinates[j] === 9) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader().load( 'textures/page4.jpeg' );			
							paper_texture.roation = Math.PI/2
							const planeMaterial = new THREE.MeshPhongMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 2;
							plane.position.z = j*20;
							plane.rotateX(Math.PI*3/2);

							const box = new THREE.Box3();
							box.setFromObject(plane);

							scene.add( plane );	
							papers.push(plane);
						}

						else if (coordinates[j] === 10) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader().load( 'textures/page5.jpeg' );			
							paper_texture.roation = Math.PI/2
							const planeMaterial = new THREE.MeshPhongMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 2;
							plane.position.z = j*20;
							plane.rotateX(Math.PI*3/2);

							const box = new THREE.Box3();
							box.setFromObject(plane);

							scene.add( plane );	
							papers.push(plane);
						}												

						else if (coordinates[j] === 11) {
							const boxGeometry = new THREE.BoxGeometry( 120, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 5, 1 );									
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20;
							box1.position.y = 15;
							box1.position.z = j*20-18.5;
							//box1.rotateY(Math.PI / 2);
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 12) { //feito
							const boxGeometry = new THREE.BoxGeometry( 80, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );								
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff , side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20;
							box1.position.y = 15;
							box1.position.z = j*20;
							box1.rotateY(Math.PI / 2);
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 13) { //feito
							const boxGeometry = new THREE.BoxGeometry( 45, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 2, 1 );								
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20-40;
							box1.position.y = 15;
							box1.position.z = j*20;
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 14) { //feito
							const boxGeometry = new THREE.BoxGeometry( 60, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );			
							const boxMaterials = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							//const boxMaterial = new THREE.MeshStandardMaterial( {map: wall_texture, side: THREE.BackSide} );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );									
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterials);

							box1.position.x = i*20+29;
							box1.position.y = 15;
							box1.position.z = j*20+19;
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 15) { // contrário da 11 //feito
							const boxGeometry = new THREE.BoxGeometry( 120, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );			
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 5, 1 );									
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20;
							box1.position.y = 15;
							box1.position.z = j*20+18.5;
							//box1.rotateY(Math.PI / 2);
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 16) { // contrário da 14 //feito
							const boxGeometry = new THREE.BoxGeometry( 90, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );			
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );									
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20+14;
							box1.position.y = 15;
							box1.position.z = j*20-19;
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 17) { // contrário da 11 //feito
							const boxGeometry = new THREE.BoxGeometry( 60, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );				
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20-10;
							box1.position.y = 15;
							box1.position.z = j*20-47.5;
							box1.rotateY(Math.PI / 2);
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 18) { // contrário da 11 //feito
							const boxGeometry = new THREE.BoxGeometry( 12.5, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 1, 1 );			
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20-38;
							box1.position.y = 15;
							box1.position.z = j*20+5;
							box1.rotateY(Math.PI / 2);
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 19) { // contrário da 11 //feito
							const boxGeometry = new THREE.BoxGeometry( 12.5, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 1, 1 );		
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20-38;
							box1.position.y = 15;
							box1.position.z = j*20-5;
							box1.rotateY(Math.PI / 2);
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 20) { //feito
							const boxGeometry = new THREE.BoxGeometry( 80, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );								
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture , side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20;
							box1.position.y = 15;
							box1.position.z = j*20;
							box1.rotateY(Math.PI / 2);
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}																				

						else if (coordinates[j] === 21) { //feito
							const boxGeometry = new THREE.BoxGeometry( 22, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 1, 1 );								
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20-28;
							box1.position.y = 15;
							box1.position.z = j*20;
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 22) { //feito
							const boxGeometry = new THREE.BoxGeometry( 22, 35, 3)
							const wall_texture = new THREE.TextureLoader().load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 1, 1 );								
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20-28;
							box1.position.y = 15;
							box1.position.z = j*20;
							
							const box = new THREE.Box3();
							box.setFromObject(box1);

							const helper = new THREE.Box3Helper( box, 0xffff00 );
							scene.add( helper );
							scene.add( box1 );	
							objects.push( box1 );
							trees.push( box );							
						}

						else if (coordinates[j] === 23) {

							const tunnelLenght = 200;
							const tunnelRad = 45;

							const cylinderGeometry = new THREE.CylinderBufferGeometry( tunnelRad, tunnelRad, tunnelLenght, 24, 1, true )
							const tunnelTexture = new THREE.TextureLoader().load( 'textures/cement.jpg' );
							const cylinderMaterial = new THREE.MeshPhongMaterial( {  map : tunnelTexture, side: THREE.DoubleSide});							
							const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );

							cylinder.position.x = i*20;
							cylinder.position.y = 30;
							cylinder.position.z = j*20;
							cylinder.rotateX(Math.PI / 2);
							cylinder.rotateZ(Math.PI/2);

							const cylinderGeometry2 = new THREE.CylinderBufferGeometry( tunnelRad+0.25, tunnelRad+0.25, tunnelLenght, 24, 1, true )							
							const cylinder2 = new THREE.Mesh( cylinderGeometry2, cylinderMaterial );

							cylinder2.position.x = i*20;
							cylinder2.position.y = 30;
							cylinder2.position.z = j*20;
							cylinder2.rotateX(Math.PI / 2);
							cylinder2.rotateZ(Math.PI/2);

							const cylinderGeometry3 = new THREE.CylinderBufferGeometry( tunnelRad+0.5, tunnelRad+0.5, tunnelLenght, 24, 1, true )							
							const cylinder3 = new THREE.Mesh( cylinderGeometry3, cylinderMaterial );

							cylinder3.position.x = i*20;
							cylinder3.position.y = 30;
							cylinder3.position.z = j*20;
							cylinder3.rotateX(Math.PI / 2);
							cylinder3.rotateZ(Math.PI/2);							

							const cylinderGeometry4 = new THREE.CylinderBufferGeometry( tunnelRad+1, tunnelRad+1, tunnelLenght, 24, 1, true )							
							const cylinder4 = new THREE.Mesh( cylinderGeometry4, cylinderMaterial );

							cylinder4.position.x = i*20;
							cylinder4.position.y = 30;
							cylinder4.position.z = j*20;
							cylinder4.rotateX(Math.PI / 2);
							cylinder4.rotateZ(Math.PI/2);		
							
							const boxGeometry = new THREE.BoxGeometry( tunnelLenght, 46, 5)		
							const collisionBox1 = new THREE.Mesh( boxGeometry);

							collisionBox1.position.x = i*20;
							collisionBox1.position.y = 20;
							collisionBox1.position.z = j*20-42;

							const collisionBox2 = new THREE.Mesh( boxGeometry);

							collisionBox2.position.x = i*20;
							collisionBox2.position.y = 20;
							collisionBox2.position.z = j*20+42;

							const box1 = new THREE.Box3();

							box1.setFromObject(collisionBox1);							

							const box2 = new THREE.Box3();
							box2.setFromObject(collisionBox2);							

							trees.push(box1)
							trees.push(box2)

							scene.add( cylinder );
							scene.add( cylinder2 );
							scene.add( cylinder3 );								
							scene.add( cylinder4 );	
						}

						else if (coordinates[j] === 99) {
							camera.position.set(i*20, 5, 20*j)
						}																			

					}
				}

				//slenderman

				const SlenderLoader = new THREE.OBJLoader();

				// load a resource
				SlenderLoader.load(
					// resource URL
					'models/slenderman/SM Model.obj',
					// called when resource is loaded
					function ( slenderMan ) {
						//object.position.lerp(camera, 0.95);
						slenderMan.position.x = 400 + Math.floor(Math.random() * 400); 
						slenderMan.position.y = 0;
						slenderMan.position.z = 400 + Math.floor(Math.random() * 400); // começar do fundo de forma randomica
						slenderMan.scale.x = 11;
            			slenderMan.scale.y = 11;
            			slenderMan.scale.z = 11;
						slenderMan.rotateY(Math.PI*11/12)
						slenderMan.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {
							const slenderTexture = new THREE.TextureLoader().load( 'models/slenderman/slenderman_color.png' );			
							child.material = new THREE.MeshStandardMaterial( {map: slenderTexture, fog: true} )
							}
						} );
						
						scene.add( slenderMan );
						slenders.push(slenderMan)						

					},

					function ( xhr ) {
						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
					},
					// called when loading has errors
					function ( error ) {
						console.log( 'An error happened' );
					}
				);		

				// flaslight

				flashLight = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 6.5, 12), new THREE.MeshBasicMaterial({color:0x212121}));
				flashLight.rotateX(Math.PI/2);
				flashLight.position.set(2,-3,0)
				camera.add(flashLight);

				spotLight1 = new THREE.SpotLight(0xcccccc, 0.5, 150);
				spotLight1.power = 3.65;
				spotLight1.angle = 0.55;
				spotLight1.decay = 2;
				spotLight1.penumbra = 0.1;
				spotLight1.distance = 200;
				spotLight1.castShadow = true;
				spotLight1.rotateX(Math.PI/2);

				spotLight2 = new THREE.SpotLight(0xcccccc, 0.5, 150);
				spotLight2.power = 1.65;
				spotLight2.angle = 0.65;
				spotLight2.decay = 2;
				spotLight2.penumbra = 0.1;
				spotLight2.distance = 200;
				spotLight2.castShadow = true;
				spotLight2.rotateX(Math.PI/2);

				spotLight3 = new THREE.SpotLight(0xffffff, 0.5, 150); //5b5e52
				spotLight3.power = 5;
				spotLight3.angle = 0.40;
				spotLight3.decay = 6;
				spotLight3.penumbra = 1;
				spotLight3.distance = 200;
				spotLight3.castShadow = true;
				spotLight3.rotateX(Math.PI/2);

				spotLight4 = new THREE.SpotLight(0xcccccc, 0.5, 150);
				spotLight4.power = 2.65;
				spotLight4.angle = 0.1;
				spotLight4.decay = 6;
				spotLight4.penumbra = 0.1;
				spotLight4.distance = 200;
				spotLight4.castShadow = true;
				spotLight4.rotateX(Math.PI/2);											


				flashLight.add(spotLight1);
				flashLight.add(spotLight1.target);				
				flashLight.add(spotLight2);
				flashLight.add(spotLight2.target);
				flashLight.add(spotLight3);
				flashLight.add(spotLight3.target);						
				flashLight.add(spotLight4);
				flashLight.add(spotLight4.target);

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//postprocessing

				composer = new THREE.EffectComposer( renderer );
				composer.addPass( new THREE.RenderPass( scene, camera ) );

				glitchPass = new THREE.GlitchPass();
				composer.addPass( glitchPass );	

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				composer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				const time = performance.now();

				if ( controls.isLocked === true ) {

					raycaster.ray.origin.copy( controls.getObject().position ); // localização
					raycaster.ray.origin.y += 10; // localização

					const intersections = raycaster.intersectObjects( scene.children ); // objects

					const onObject = intersections.length > 0;

					const delta = ( time - prevTime ) / 1000;

					// Set the velocity.x and velocity.z using the calculated time delta
					if (run && stamina > 1) {
						moveSpeed = baseMoveSpeed*0.66;
						stamina -= 1;
					} else {
						moveSpeed = baseMoveSpeed;
						if(stamina <= 98.8) stamina += 0.055;
					}

					velocity.x -= velocity.x * moveSpeed * delta; //movement speed
					velocity.z -= velocity.z * moveSpeed * delta; //movement speed

					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveRight ) - Number( moveLeft );
					direction.normalize(); // this ensures consistent movements in all directions

					// Update the position using the changed delta
					if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;					

					controls.moveRight( - velocity.x * delta );
					controls.moveForward( - velocity.z * delta );

					controls.getObject().position.y += ( velocity.y * delta ); // new behavior

					// Prevent the camera/player from falling out of the 'world'
					if ( controls.getObject().position.y < 18 ) {

						velocity.y = 0;
						controls.getObject().position.y = 18;

					}					

					for(var i = 0; i < trees.length; i++) {
						if ( raycaster.ray.intersectsBox( trees[i] ) === true) { 
							velocity.x = 0;
							velocity.z = 0;
							controls.getObject().position.x = origem.x;
							controls.getObject().position.y = origem.y;
							controls.getObject().position.z = origem.z;
							console.log('Colisão')

						}}

					for(var i = 0; i < papers.length; i++) {
						var aux = raycaster.ray.origin.clone();
						aux.y = 10;
						if ( aux.distanceTo(papers[i].position) <= 15 && interact === true) {
							scene.remove(papers[i]);
							papers.splice(papers.indexOf(papers[i]), 1);
							const AudioLoader = new THREE.AudioLoader();							
							if(pageFlipSound.isPlaying === false)
								AudioLoader.load( 'sounds/page_flip.mp3', function( buffer ) {
									pageFlipSound.setBuffer( buffer );
									pageFlipSound.setLoop( false );
									pageFlipSound.setVolume( 0.4 );
									pageFlipSound.play();
								});
							collectPages += 1;
							slenderSpeed += 0.001;		
						}
					}

					if ( raycaster.ray.origin.distanceTo(slenders[0].position) < 110) { 
						console.log('Perto');

						spotLight1.power = Math.floor(Math.random() * 6);
						spotLight2.power = Math.floor(Math.random() * 5);
						spotLight3.power = Math.floor(Math.random() * 10);
						spotLight4.power = Math.floor(Math.random() * 9);					

						if (raycaster.ray.origin.distanceTo(slenders[0].position) <  60) { //60
						
							controls.disconnect();
							camera.rotation.y = Math.atan2(( slenders[0].position.z - camera.position.z ) , ( slenders[0].position.x - camera.position.x ));
							glitchPass.goWild = true;

							const AudioLoader = new THREE.AudioLoader();
							if(slenderStaticSound.isPlaying === false)
							AudioLoader.load( 'sounds/slender_static.mp3', function( buffer ) {
								slenderStaticSound.setBuffer( buffer );
								slenderStaticSound.setLoop( false );
								slenderStaticSound.setVolume( 0.25 );
								slenderStaticSound.play();
								document.removeEventListener('keydown', onKeyDown);
								setTimeout(() => {  open(location, '_self').close(); }, 7500);
							});
						}
					} else {
						spotLight1.power = 3.65;
						spotLight2.power = 1.65;
						spotLight3.power = 5;
						spotLight4.power = 2.65;						
					}

				}

				origem = raycaster.ray.origin.clone();
				origem.y -= 10;	

				if(moveBackward || moveForward || moveLeft || moveRight) {
					const AudioLoader = new THREE.AudioLoader();
					if(stepSound.isPlaying === false) {
					AudioLoader.load( 'sounds/step' + Math.floor(Math.random() * 2) + '.mp3', function( buffer ) {
						stepSound.setBuffer( buffer );
						stepSound.setLoop( false);
						stepSound.setVolume( 0.4 );
						stepSound.play();
						});
					}
				}

				if(papers.length <= 0) {
					gameover.style.visibility = 'visible';						
					slenderSpeed = 0.02;
					console.log('Acabou!')
				};

				// movimentação slenderMan

				slenders[0].rotation.y = Math.atan2(( camera.position.z - slenders[0].position.z ) , ( camera.position.x - slenders[0].position.x ));
				slenders[0].position.lerp(camera.position, slenderSpeed)
				if (slenders[0].position. y > 1) slenders[0].position.y = 1;

				//

				prevTime = time;
			composer.render( );
			}
		</script>
	</body>
</html>
