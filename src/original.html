<!DOCTYPE html>
<html>
    <head>
        <title>Three.js Crash Course</title>

        <style>
        	body { margin: 0; }
        	canvas { width: 100%; height:100%;};
    	</style>
    </head>

    <body>
    	
    	<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/OBJLoader.js"></script>

    	<script>
    		(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()
    		var scene = new THREE.Scene();
    		var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

    		var renderer = new THREE.WebGLRenderer( );
    		renderer.setSize( window.innerWidth, window.innerHeight );
    		document.body.appendChild( renderer.domElement );

    		window.addEventListener('resize', function()
    		{
    			var width = window.innerWidth;
    			var height = window.innerHeight;
    			renderer.setSize( width, height);
    			camera.aspect = width / height;
    			camera.updateProjectionMatrix();
    		});

    		controls = new THREE.OrbitControls( camera, renderer.domElement);

    		const axesHelper = new THREE.AxesHelper( 5 );
			scene.add( axesHelper );

			var geometry = new THREE.CircleBufferGeometry( 5, 20 );
			water = new Water( geometry, {
					color: params.color,
					scale: params.scale,
					flowDirection: new THREE.Vector2( params.flowX, params.flowY ),
					textureWidth: 1024,
					textureHeight: 1024
				} );

			water.position.x = 4;
			water.rotation.x = Math.PI * - 0.5;
			scene.add( water );

			var geometry = new THREE.CircleBufferGeometry( 2, 20 );
			water = new Water( geometry, {
					color: params.color,
					scale: params.scale,
					flowDirection: new THREE.Vector2( params.flowX, params.flowY ),
					textureWidth: 1024,
					textureHeight: 1024
				} );

			water.position.x = -2;
			water.rotation.x = Math.PI * - 0.5;
			scene.add( water );			

			var geometry = new THREE.CircleBufferGeometry( 3, 20 );
			water = new Water( geometry, {
					color: params.color,
					scale: params.scale,
					flowDirection: new THREE.Vector2( params.flowX, params.flowY ),
					textureWidth: 1024,
					textureHeight: 1024
				} );

			water.position.y = 2;
			water.rotation.x = Math.PI * - 0.5;
			scene.add( water );			

			geometry = new THREE.CircleBufferGeometry( 3, 20 );
			material = new THREE.MeshBasicMaterial( { color: 0xff0000, side: THREE.DoubleSide } );
			const circle3 = new THREE.Mesh( geometry, material );
			circle3.position.y = 2;

			geometry = new THREE.CircleBufferGeometry( 4, 20 );
			material = new THREE.MeshBasicMaterial( { color: 0x0000ff, side: THREE.DoubleSide } );
			const circle4 = new THREE.Mesh( geometry, material );
			circle4.position.y = -3;
			circle4.position.x = 7;
			scene.add( circle1 );
			scene.add( circle2 );
			scene.add( circle3 );
			scene.add( circle4 );

    		camera.position.z = 10

    		var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    		scene.add(ambientLight);

    		var light1 = new THREE.PointLight(0xff0040, 3, 50);
    		//scene.add(light1);

    		var light2 = new THREE.PointLight(0x0040ff, 2, 50);
    		//scene.add(light2);

    		var light3 = new THREE.PointLight(0x80ff80, 4, 50);
    		//scene.add(light3);

    		var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    		directionalLight.position.set(0,1,0);
    		//scene.add(directionalLight);

    		var spotLight = new THREE.SpotLight(0xff45F6, 10);
    		spotLight.position.set(0,1,0);
    		//scene.add(spotLight);

    		// game logic
    		var update = function ( )
    		{

    			var time = Date.now() * 0.0005;

    			light1.position.x = Math.sin(time*0.7) * 30;
    			light1.position.x = Math.cos(time*0.5) * 40;
    			light1.position.x = Math.cos(time*0.3) * 30;

    			light2.position.x = Math.cos(time*0.3) * 30;
    			light2.position.x = Math.sin(time*0.5) * 40;
    			light2.position.x = Math.sin(time*0.7) * 30;

    			light3.position.x = Math.sin(time*0.7) * 30;
    			light3.position.x = Math.cos(time*0.3) * 40;
    			light3.position.x = Math.sin(time*0.5) * 30;

    		};

    		// draw scene
    		var render = function( )
    		{
    			renderer.render( scene, camera);    			
    		};

    		//run game loop (update, render, repeat)
    		var GameLoop = function( )
    		{
    			requestAnimationFrame( GameLoop );

    			update( );
    			render( );
    		};

    		GameLoop( );
    	</script>

    </body>
</html>