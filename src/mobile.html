<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Slenderman</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" href="css/style.css">
        <style>
        	body { margin: 0; }
        	canvas { width: 100%; height:100%;};
		</style>
	</head>
	<body>	
		<section id="loading-screen">
			<div id="loader"></div>
		</section>
		<div id="gameover">
			<br /><br />
			<span style="font-size:60px;color:#8d1212">Thank you for the pages</span>
		</div>
		<div id="blocker">
			<div id="instructions">
				<span style="font-size:52px;color:#8d1212">Collect the pages to escape</span>
				<br /><br />				
				<span style="font-size:40px">Click to play</span>
				<br /><br />
				<span style="font-size:30px">Move: WASD<br/>
				Look: MOUSE<br/>
				E: COLLECT PAGE<br/>
				Shift: RUN</span>
			</div>
		</div>
		<div id="pages">
			<span></span>
		</div>
		<div style="position: relative;" id="container">
			<div style="position: relative;" id="container3d"></div>
		</div>	

		<script src="js/three.js"></script>
		<script src="js/three.module.js"></script>
		<script src="js/PointerLockControls.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/EffectComposer.js"></script>
		<script src="js/ShaderPass.js"></script>
		<script src="js/CopyShader.js"></script>
		<script src="js/RenderPass.js"></script>
		<script src="js/GlitchPass.js"></script>
		<script src="js/DigitalGlitch.js"></script>

		<script type="text/javascript" src="touch/js/movement-pad.js"></script>
		<script type="text/javascript" src="touch/js/rotation-pad.js"></script>
		<script type="text/javascript" src="touch/js/touch-controls.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js" type="text/javascript"></script>		
		
		<script src="maps.js" charset="UTF-8"></script>
		
		<script type="module">
			let camera, scene, renderer, controls, flashLight, spotLight1, spotLight2, spotLight3, spotLight4,slenderMan, origem, composer, glitchPass, onKeyDown, moveSpeed, rustedCar;
			let raycaster;

			let moveForward = false;
			let moveBackward = false;
			let moveLeft = false;
			let moveRight = false;
			let run = false;
			let interact = false;
			let lanternPicked = false;
			let gateClosed = false;
			let onWater, flashLightBody, flashLightLamp, flashLightCircle;

			const objects = [];
			const papers = [];
			const slenders = [];
			const water = [];
			let forestSound, stepSound, slenderStaticSound, pageFlipSound, rainSound, flashLightClickSound, gateClosingSound;
			var slenderSpeed = 0.0;
			var baseSlenderSpeed = 0;//0.0025;
			var collectPages = 0;
			var inicialPapersLenght = 0;

			var baseMoveSpeed = 7.5; //maior mais devagar
			var stamina = 100;
			const mouseSpeed = 0.0008;

			let rainGeo, rainCount, rain, rainDrop;			

			// Save the current time
			let prevTime = performance.now();
			const velocity = new THREE.Vector3();
			const direction = new THREE.Vector3();
			const vertex = new THREE.Vector3();
			const color = new THREE.Color();

			var coordArray = getMap();

			var loadingScreen = {
				scene: new THREE.Scene(),
				camera: new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.6, 1000 ),
			};
			var loadingManager = null;
			var RESOURCES_LOADED = false;		
			var container = $("#container3d");
			var elem = document.documentElement;

			function openFullscreen() {
				if (elem.requestFullscreen) {
					elem.requestFullscreen();
				} else if (elem.webkitRequestFullscreen) { /* Safari */
					elem.webkitRequestFullscreen();
				} else if (elem.msRequestFullscreen) { /* IE11 */
					elem.msRequestFullscreen();
				}
			}

			var options = {
					speedFactor: 0.1,
					delta: 1,
					rotationFactor: 0.003,
					maxPitch: 55,
					hitTest: false
				};

			init();
			animate();

			var AudioLoader = new THREE.AudioLoader(loadingManager);
			const listener = new THREE.AudioListener();

			function init() {				

				loadingManager = new THREE.LoadingManager();

				const loadingScreenCSS = document.getElementById( 'loading-screen' );
				loadingManager = new THREE.LoadingManager( () => {
					loadingScreenCSS.classList.add( 'fade-out' );
				} );
				
				loadingManager.onLoad = function(){
					loadingScreenCSS.remove();
					RESOURCES_LOADED = true;
					blocker.style.visibility = 'visible';
					instructions.style.visibility = 'visible';
				};

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.6, 1000 );
				camera.position.set(850, 10, 560);
				camera.rotation.y = -5;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );
				scene.fog = new THREE.Fog( 0xffffff, 2, 0 );

				controls = new TouchControls(container.parent(), camera, options);
				controls.addToScene(scene);

				const light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 1.00 );  // ( 0xeeeeff, 0x777788, 0.5 )
				light.position.set( 0.5, 1, 0.75 );
				//scene.add(light);

				const blocker = document.getElementById( 'blocker' );
				const instructions = document.getElementById( 'instructions' );
				const gameover = document.getElementById( 'gameover' );
				const pages = document.getElementById( 'pages' );				

				instructions.addEventListener( 'click', function () {

					instructions.style.display = 'none';
					blocker.style.display = 'none';
					pages.style.visibility = 'visible';
					
					// create an AudioListener and add it to the camera
					camera.add( listener );

					if(gateClosed === false) {

						openFullscreen();
						gateClosingSound = new THREE.Audio( listener );
						AudioLoader.load( 'sounds/gateClosingSound.mp3', function( buffer ) {
						gateClosingSound.setBuffer( buffer );
						gateClosingSound.setLoop( false );
						gateClosingSound.setVolume( 0.6 );
						gateClosingSound.play();
						gateClosed = true;
					});

					}

					forestSound = new THREE.Audio( listener );
					rainSound = new THREE.Audio( listener );
					flashLightClickSound = new THREE.Audio( listener );
					
					AudioLoader.load( 'sounds/forest.mp3', function( buffer ) {
						forestSound.setBuffer( buffer );
						forestSound.setLoop( true );
						forestSound.setVolume( 0.25 );
						forestSound.play();
					});
					AudioLoader.load( 'sounds/rain1.mp3', function( buffer ) {
						rainSound.setBuffer( buffer );
						rainSound.setLoop( true );
						rainSound.setVolume( 0.08 );
						rainSound.play();
					});

					// create a global audio source
					stepSound = new THREE.Audio( listener );
					slenderStaticSound = new THREE.Audio( listener );
					pageFlipSound = new THREE.Audio( listener );

					slenderSpeed = baseSlenderSpeed + collectPages*0.0025;
				}, false );

				console.log(controls)
				// Permis√£o 
				console.log(container)

				// floor

				let floorGeometry = new THREE.PlaneBufferGeometry( 1000, 1220, 100, 100 );
				floorGeometry.rotateX( - Math.PI / 2 );

				// vertex displacement

				let position = floorGeometry.attributes.position;

				for ( let i = 0, l = position.count; i < l; i ++ ) {

					vertex.fromBufferAttribute( position, i );

					vertex.x += Math.random() * 20 - 10;
					vertex.y += Math.random() * 2;
					vertex.z += Math.random() * 20 - 10;

					position.setXYZ( i, vertex.x, vertex.y, vertex.z );

				}

				// ensure each face has unique vertices
				floorGeometry = floorGeometry.toNonIndexed(); 

				const floor_texture = new THREE.TextureLoader(loadingManager).load( 'textures/grass1.jpg' );
				const floorMaterial = new THREE.MeshPhongMaterial( { map : floor_texture } );
				floor_texture.wrapS = THREE.RepeatWrapping;
				floor_texture.wrapT = THREE.RepeatWrapping;
				floor_texture.repeat.set( 12, 12 );				

				const floor = new THREE.Mesh( floorGeometry, floorMaterial );
				floor.position.x = 430;
				floor.position.z = 540;
				scene.add( floor );

				// objects

				for ( let i = 0; i < coordArray.length; i++) {
					var coordinates = coordArray[i]
					
					for(var j = 0; j < coordinates.length; j++) {
						if (coordinates[j] === 1) {
							const cylinderGeometry = new THREE.CylinderBufferGeometry( 10, 10, 200 ).toNonIndexed();
							const three_texture = new THREE.TextureLoader(loadingManager).load( 'textures/arvore.jpeg' );
							const cylinderMaterial = new THREE.MeshPhongMaterial( {  map : three_texture} );							
							const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
							
							cylinder.position.x = i*20;
							cylinder.position.y = 95;
							cylinder.position.z = j*20;
							
							const box = new THREE.Box3();
							box.setFromObject(cylinder);

							scene.add( cylinder );
							objects.push( box );
						}

						else if (coordinates[j] === 2) {

							const containerLenght = 80;
							const containerHeight = 50;

							var planeGeometry = new THREE.PlaneBufferGeometry( containerLenght, containerHeight)
							const container_texture = new THREE.TextureLoader(loadingManager).load( 'textures/container.png' );			
							const planeMaterial = new THREE.MeshStandardMaterial( {map: container_texture, side: THREE.DoubleSide} );
							var plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 20;
							plane.position.z = j*20-20;

							const boxGeometry = new THREE.BoxBufferGeometry( containerLenght, containerHeight, 2)		
							const collisionBox1 = new THREE.Mesh( boxGeometry);
							
							collisionBox1.position.x = i*20;
							collisionBox1.position.y = 20;
							collisionBox1.position.z = j*20-20;

							const box1 = new THREE.Box3();
							box1.setFromObject(collisionBox1);	

							scene.add( plane );	
							objects.push( box1 );

							plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 20;
							plane.position.z = j*20+20;
	
							const collisionBox2 = new THREE.Mesh( boxGeometry);

							collisionBox2.position.x = i*20;
							collisionBox2.position.y = 20;
							collisionBox2.position.z = j*20+20;

							const box2 = new THREE.Box3();
							box2.setFromObject(collisionBox2);	

							scene.add( plane );	
							objects.push( box2 );	

							planeGeometry = new THREE.PlaneGeometry( 80, 40)			
							plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 45;
							plane.position.z = j*20;
							plane.rotateX(Math.PI / 2)

							scene.add( plane );								

						}

						else if (coordinates[j] === 5) {
							const boxGeometry = new THREE.BoxBufferGeometry( 80, 40, 3)
							const wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/wall.jpg' );
							const wall_texture2 = new THREE.TextureLoader(loadingManager).load( 'textures/wall.jpg' );
							wall_texture2.wrapS = THREE.RepeatWrapping;
							wall_texture2.wrapT = THREE.RepeatWrapping;
							wall_texture2.repeat.set( 0.1, 1 );
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];

							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20;
							box1.position.y = 20;
							box1.position.z = j*20;
							
							const collisionBox1 = new THREE.Box3();
							collisionBox1.setFromObject(box1);

							scene.add( box1 );	
							objects.push( collisionBox1 );	

							const box2 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box2.position.x = i*20;
							box2.position.y = 20;
							box2.position.z = j*20;
							box2.rotateY(Math.PI / 2);
							
							const collisionBox2 = new THREE.Box3();
							collisionBox2.setFromObject(box2);

							scene.add( box2 );	
							objects.push( collisionBox2 );							
						}

						else if (coordinates[j] === 6) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader(loadingManager).load( 'textures/page1.jpeg' );
							const planeMaterial = new THREE.MeshPhongMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 2;
							plane.position.z = j*20;
							plane.rotateX(Math.PI*3/2);

							const box = new THREE.Box3();
							box.setFromObject(plane);

							scene.add( plane );	
							papers.push(plane);
						}

						else if (coordinates[j] === 7) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader(loadingManager).load( 'textures/page2.jpeg' );
							paper_texture.roation = Math.PI/2
							const planeMaterial = new THREE.MeshStandardMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20+7;
							plane.position.y = 16;
							plane.position.z = j*20-18.4;
							plane.rotateX(Math.PI*2);

							const box = new THREE.Box3();
							box.setFromObject(plane);
							
							scene.add( plane );	
							papers.push(plane);
						}			

						else if (coordinates[j] === 8) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader(loadingManager).load( 'textures/page3.jpeg' );			
							paper_texture.roation = Math.PI/2
							const planeMaterial = new THREE.MeshPhongMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20+10;
							plane.position.y = 12;
							plane.position.z = j*20+1.8;
							plane.rotateX(Math.PI*2);

							const box = new THREE.Box3();
							box.setFromObject(plane);

							scene.add( plane );	
							papers.push(plane);
						}

						else if (coordinates[j] === 9) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader(loadingManager).load( 'textures/page4.jpeg' );
							const planeMaterial = new THREE.MeshPhongMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20+6.4;
							plane.position.y = 14.1;
							plane.position.z = j*20-3;
							plane.rotateX(Math.PI/2);
							plane.rotateY(Math.PI);

							const box = new THREE.Box3();
							box.setFromObject(plane);

							scene.add( plane );	
							papers.push(plane);
						}

						else if (coordinates[j] === 10) {
							const planeGeometry = new THREE.PlaneGeometry( 2.5, 4)
							const paper_texture = new THREE.TextureLoader(loadingManager).load( 'textures/page5.jpeg' );			
							paper_texture.roation = Math.PI/2
							const planeMaterial = new THREE.MeshPhongMaterial( {map: paper_texture, side: THREE.DoubleSide} );
							const plane = new THREE.Mesh( planeGeometry,  planeMaterial);

							plane.position.x = i*20;
							plane.position.y = 2;
							plane.position.z = j*20;
							plane.rotateX(Math.PI*3/2);

							const box = new THREE.Box3();
							box.setFromObject(plane);

							scene.add( plane );	
							papers.push(plane);
						}												

						else if (coordinates[j] === 11) {
							var boxGeometry = new THREE.BoxBufferGeometry( 45, 35, 3)
							var wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 2, 1 );

							const wall_texture2 = new THREE.TextureLoader(loadingManager).load( 'textures/dirty_wall.jpg' );
							wall_texture2.wrapS = THREE.RepeatWrapping;
							wall_texture2.wrapT = THREE.RepeatWrapping;
							wall_texture2.repeat.set( 1, 1 );

							const wall_texture3 = new THREE.TextureLoader(loadingManager).load( 'textures/dirty_wall.jpg' );
							wall_texture3.wrapS = THREE.RepeatWrapping;
							wall_texture3.wrapT = THREE.RepeatWrapping;
							wall_texture3.repeat.set( 0.1, 1 );							
							
							var boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20-40;
							box1.position.y = 15;
							box1.position.z = j*20;
							
							const collisionBox1 = new THREE.Box3();
							collisionBox1.setFromObject(box1);

							const box2 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box2.position.x = i*20-40;
							box2.position.y = 15;
							box2.position.z = j*20-40;

							const collisionBox2 = new THREE.Box3();
							collisionBox2.setFromObject(box2);							

							scene.add( box1 );	
							objects.push( collisionBox1 );							

							scene.add( box2 );	
							objects.push( collisionBox2 );

							//// PAREDE ESQUERDA DA PORTA DE ENTRADA

							boxGeometry = new THREE.BoxBufferGeometry( 22, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 1, 1 );								
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box3 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box3.position.x = i*20-8;
							box3.position.y = 15;
							box3.position.z = j*20;
							
							const collisionBox3 = new THREE.Box3();
							collisionBox3.setFromObject(box3);

							scene.add( box3 );	
							objects.push( collisionBox3 );	

							///							

							boxGeometry = new THREE.BoxBufferGeometry( 22, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 1, 1 );								
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box4 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box4.position.x = i*20-8;
							box4.position.y = 15;
							box4.position.z = j*20-40;
							
							const collisionBox4 = new THREE.Box3();
							collisionBox4.setFromObject(box4);

							scene.add( box4 );	
							objects.push( collisionBox4 );

							///

							boxGeometry = new THREE.BoxBufferGeometry( 12.5, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 1, 1 );			
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({color: 0xcce0eb, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box5 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box5.position.x = i*20+1.5;
							box5.position.y = 15;
							box5.position.z = j*20-35;
							box5.rotateY(Math.PI / 2);
							
							const collisionBox5 = new THREE.Box3();
							collisionBox5.setFromObject(box5);

							scene.add( box5 );	
							objects.push( collisionBox5 );	

							///

							boxGeometry = new THREE.BoxBufferGeometry( 12.5, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 1, 1 );			
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box6 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box6.position.x = i*20+1.5;
							box6.position.y = 15;
							box6.position.z = j*20-5;
							box6.rotateY(Math.PI / 2);
							
							const collisionBox6 = new THREE.Box3();
							collisionBox6.setFromObject(box6);

							scene.add( box6 );	
							objects.push( collisionBox6 );	

							/// LATERAL DIREITA INFERIOR EXTERTA

							boxGeometry = new THREE.BoxBufferGeometry( 80, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );								
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box7 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box7.position.x = i*20-19;
							box7.position.y = 15;
							box7.position.z = j*20-80;
							box7.rotateY(Math.PI / 2);
							
							const collisionBox7 = new THREE.Box3();
							collisionBox7.setFromObject(box7);

							scene.add( box7 );	
							objects.push( collisionBox7 );

							/// LATERAL ESQUERDA INFERIOR EXTERTA

							boxGeometry = new THREE.BoxBufferGeometry( 80, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );								
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box8 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box8.position.x = i*20-19;
							box8.position.y = 15;
							box8.position.z = j*20+40;
							box8.rotateY(Math.PI / 2);
							
							const collisionBox8 = new THREE.Box3();
							collisionBox8.setFromObject(box8);

							scene.add( box8 );	
							objects.push( collisionBox8 );

							/// LATERAL DIREITA EXTERNA

							boxGeometry = new THREE.BoxBufferGeometry( 120, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 5, 1 );									
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box9 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box9.position.x = i*20-80;
							box9.position.y = 15;
							box9.position.z = j*20-118.5;
							
							const collisionBox9 = new THREE.Box3();
							collisionBox9.setFromObject(box9);

							scene.add( box9 );	
							objects.push( collisionBox9 );

							/// LATERAL ESQUERDA EXTERNA

							boxGeometry = new THREE.BoxBufferGeometry( 120, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 5, 1 );									
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box10 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box10.position.x = i*20-80;
							box10.position.y = 15;
							box10.position.z = j*20+78.5;
							
							const collisionBox10 = new THREE.Box3();
							collisionBox10.setFromObject(box10);

							scene.add( box10 );	
							objects.push( collisionBox10 );

							/// LATERAL DIREITA EXTERNA SUPERIOR

							boxGeometry = new THREE.BoxBufferGeometry( 80, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );								
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture , side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box11 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box11.position.x = i*20-140;
							box11.position.y = 15;
							box11.position.z = j*20-80;
							box11.rotateY(Math.PI / 2);
							
							const collisionBox11 = new THREE.Box3();
							collisionBox11.setFromObject(box11);

							scene.add( box11 );	
							objects.push( collisionBox11 );

							/// LATERAL ESQUERDA EXTERNA SUPERIOR

							boxGeometry = new THREE.BoxBufferGeometry( 80, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );								
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture , side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box12 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box12.position.x = i*20-140;
							box12.position.y = 15;
							box12.position.z = j*20+40;
							box12.rotateY(Math.PI / 2);
							
							const collisionBox12 = new THREE.Box3();
							collisionBox12.setFromObject(box12);

							scene.add( box12 );	
							objects.push( collisionBox12 );								

							/// DIREITA INTERIOR SUPERIOR

							boxGeometry = new THREE.BoxBufferGeometry( 60, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );			
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];

							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );

							const box13 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box13.position.x = i*20-111.5;
							box13.position.y = 15;
							box13.position.z = j*20-40;
							
							const collisionBox13 = new THREE.Box3();
							collisionBox13.setFromObject(box13);

							scene.add( box13 );	
							objects.push( collisionBox13 );

							/// ESQUERDA INTERIOR SUPERIOR

							boxGeometry = new THREE.BoxBufferGeometry( 60, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );			
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 4, 1 );
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];

							const box14 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box14.position.x = i*20-111.5;
							box14.position.y = 15;
							box14.position.z = j*20;
							
							const collisionBox14 = new THREE.Box3();
							collisionBox14.setFromObject(box14);

							scene.add( box14 );	
							objects.push( collisionBox14 );

							/// PARTE EXTERIOR ESQUERDA PORTA

							boxGeometry = new THREE.BoxBufferGeometry( 28, 35, 3)
							wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/bathroom_wall.png' );			
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 2, 1 );
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];

							const box15 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box15.position.x = i*20-155;
							box15.position.y = 15;
							box15.position.z = j*20;
							
							const collisionBox15 = new THREE.Box3();
							collisionBox15.setFromObject(box15);

							scene.add( box15 );	
							objects.push( collisionBox15 );														

							/// PARTE SUPERIOR DA ENTRADA

							boxGeometry = new THREE.BoxBufferGeometry( 60, 35, 3)
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box16 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box16.position.x = i*20-170;
							box16.position.y = 15;
							box16.position.z = j*20-28.5;
							box16.rotateY(Math.PI / 2);
							
							const collisionBox16 = new THREE.Box3();
							collisionBox16.setFromObject(box16);

							scene.add( box16 );	
							objects.push( collisionBox16 );	

							/// TETO MEIO

							boxGeometry = new THREE.BoxBufferGeometry( 124, 200, 3)
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box17 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box17.position.x = i*20-79.5;
							box17.position.y = 32.5;
							box17.position.z = j*20-20;
							box17.rotateX(Math.PI*3/2);
							
							scene.add( box17 );	

							/// TETO PORTA

							boxGeometry = new THREE.BoxBufferGeometry( 22, 43, 3)
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2 , side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box18 = new THREE.Mesh( boxGeometry, boxMaterial);

							box18.position.x = i*20-8;
							box18.position.y = 32.5;
							box18.position.z = j*20-20;
							box18.rotateX(Math.PI*3/2);

							scene.add( box18 );								

							/// TETO SA√çDA

							boxGeometry = new THREE.BoxBufferGeometry( 31, 60, 3)
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2 , side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box19 = new THREE.Mesh( boxGeometry, boxMaterial);

							box19.position.x = i*20-156;
							box19.position.y = 32.5;
							box19.position.z = j*20-28.5;
							box19.rotateX(Math.PI*3/2);
							
							scene.add( box19 );	

							/// CHAO MEIO

							boxGeometry = new THREE.BoxBufferGeometry( 124, 200, 3)
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box20 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box20.position.x = i*20-79.5;
							box20.position.y = 0.45;
							box20.position.z = j*20-20;
							box20.rotateX(Math.PI*3/2);
							
							scene.add( box20 );	

							// CHAO PORTA

							boxGeometry = new THREE.BoxBufferGeometry( 22, 43, 3)
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2 , side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box21 = new THREE.Mesh( boxGeometry, boxMaterial);

							box21.position.x = i*20-8;
							box21.position.y = 0.45;
							box21.position.z = j*20-20;
							box21.rotateX(Math.PI*3/2);

							scene.add( box21 );	

							/// CHAO SA√çDA

							boxGeometry = new THREE.BoxBufferGeometry( 31, 60, 3)
							boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture3, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2 , side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture2, side: THREE.DoubleSide}) // BACK SIDE
								];
							const box22 = new THREE.Mesh( boxGeometry, boxMaterial);

							box22.position.x = i*20-156;
							box22.position.y = 0.45;
							box22.position.z = j*20-28.5;
							box22.rotateX(Math.PI*3/2);
							
							scene.add( box22 );	


						}

						else if (coordinates[j] === 12) {

							const height = 2.2;
							const materialType = THREE.MeshLambertMaterial;
							const color = 0x2389da;
							const texture = new THREE.TextureLoader(loadingManager).load( 'textures/black_water.jpg' );		
							const scale = 20;

							var geometry = new THREE.CircleBufferGeometry( 4 + scale, 16 );
							var material = new materialType( { map: texture } );
							var circle = new THREE.Mesh( geometry, material );

							circle.position.x = i*20+15;
							circle.position.y = height;
							circle.position.z = j*20;							
							circle.rotation.x = Math.PI * - 0.5;
							scene.add( circle );
							water.push( circle );

							geometry = new THREE.CircleBufferGeometry( 2 + scale, 16 );
							material = new materialType( { map: texture } );
							circle = new THREE.Mesh( geometry, material );

							circle.position.x = i*20-12;
							circle.position.y = height;
							circle.position.z = j*20+8;
							circle.rotation.x = Math.PI * - 0.5;
							scene.add( circle );
							water.push( circle );

							geometry = new THREE.CircleBufferGeometry( 3 + scale, 16 );
							material = new materialType( { map: texture } );
							circle = new THREE.Mesh( geometry, material );

							circle.position.x = i*20+5;
							circle.position.y = height;
							circle.position.z = j*20+8;
							circle.rotation.x = Math.PI * - 0.5;
							scene.add( circle );
							water.push( circle );	
		
						}

						else if (coordinates[j] === 13) {

							const tunnelLenght = 200;
							const tunnelRad = 45;

							const cylinderGeometry = new THREE.CylinderBufferGeometry( tunnelRad, tunnelRad, tunnelLenght, 24, 1, true )
							const tunnelTexture = new THREE.TextureLoader(loadingManager).load( 'textures/cement.jpg' );
							const cylinderMaterial = new THREE.MeshPhongMaterial( {  map : tunnelTexture, side: THREE.DoubleSide});							
							const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );

							cylinder.position.x = i*20;
							cylinder.position.y = 30;
							cylinder.position.z = j*20;
							cylinder.rotateX(Math.PI / 2);
							cylinder.rotateZ(Math.PI/2);

							const cylinderGeometry2 = new THREE.CylinderBufferGeometry( tunnelRad+0.25, tunnelRad+0.25, tunnelLenght, 24, 1, true )							
							const cylinder2 = new THREE.Mesh( cylinderGeometry2, cylinderMaterial );

							cylinder2.position.x = i*20;
							cylinder2.position.y = 30;
							cylinder2.position.z = j*20;
							cylinder2.rotateX(Math.PI / 2);
							cylinder2.rotateZ(Math.PI/2);

							const cylinderGeometry3 = new THREE.CylinderBufferGeometry( tunnelRad+0.5, tunnelRad+0.5, tunnelLenght, 24, 1, true )							
							const cylinder3 = new THREE.Mesh( cylinderGeometry3, cylinderMaterial );

							cylinder3.position.x = i*20;
							cylinder3.position.y = 30;
							cylinder3.position.z = j*20;
							cylinder3.rotateX(Math.PI / 2);
							cylinder3.rotateZ(Math.PI/2);							

							const cylinderGeometry4 = new THREE.CylinderBufferGeometry( tunnelRad+1, tunnelRad+1, tunnelLenght, 24, 1, true )							
							const cylinder4 = new THREE.Mesh( cylinderGeometry4, cylinderMaterial );

							cylinder4.position.x = i*20;
							cylinder4.position.y = 30;
							cylinder4.position.z = j*20;
							cylinder4.rotateX(Math.PI / 2);
							cylinder4.rotateZ(Math.PI/2);		
							
							const boxGeometry = new THREE.BoxBufferGeometry( tunnelLenght, 46, 5)		
							const collisionBox1 = new THREE.Mesh( boxGeometry);

							collisionBox1.position.x = i*20;
							collisionBox1.position.y = 20;
							collisionBox1.position.z = j*20-42;

							const collisionBox2 = new THREE.Mesh( boxGeometry);

							collisionBox2.position.x = i*20;
							collisionBox2.position.y = 20;
							collisionBox2.position.z = j*20+42;

							const box1 = new THREE.Box3();

							box1.setFromObject(collisionBox1);							

							const box2 = new THREE.Box3();
							box2.setFromObject(collisionBox2);							

							objects.push(box1)
							objects.push(box2)

							scene.add( cylinder );
							scene.add( cylinder2 );
							scene.add( cylinder3 );								
							scene.add( cylinder4 );	
						}

						else if (coordinates[j] === 14) {

						const tunnelLenght = 20;
						const tunnelRad = 12
						const secondRad = tunnelRad + 4;

						const cylinderGeometry = new THREE.CylinderBufferGeometry( tunnelRad, tunnelRad, tunnelLenght, 24, 1, true )
						const tunnelTexture = new THREE.TextureLoader(loadingManager).load( 'textures/wall.jpg' );
						const cylinderMaterial = new THREE.MeshStandardMaterial( {  map : tunnelTexture, side: THREE.DoubleSide});							
						const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );

						cylinder.position.x = i*20;
						cylinder.position.y = 2;
						cylinder.position.z = j*20;

						const cylinderGeometry2 = new THREE.CylinderBufferGeometry( secondRad, secondRad, tunnelLenght, 24, 1, true )							
						const cylinder2 = new THREE.Mesh( cylinderGeometry2, cylinderMaterial );

						cylinder2.position.x = i*20;
						cylinder2.position.y = 2;
						cylinder2.position.z = j*20;

						const torusGeometry = new THREE.TorusBufferGeometry( secondRad-2, 3, 16, 16 );
						const torusMaterial = new THREE.MeshStandardMaterial( { map: tunnelTexture } );
						const torus = new THREE.Mesh( torusGeometry, torusMaterial );

						torus.position.x = i*20;
						torus.position.y = tunnelLenght-10;
						torus.position.z = j*20;
						torus.rotateX(Math.PI/2)

						const geometry = new THREE.CircleBufferGeometry( tunnelRad, 16 );
						const blackWaterTexture = new THREE.TextureLoader(loadingManager).load( 'textures/black_water.jpg' );						
						const material = new THREE.MeshStandardMaterial( { map: blackWaterTexture } );
						const circle = new THREE.Mesh( geometry, material );

						circle.position.x = i*20;
						circle.position.y = tunnelLenght-15;
						circle.position.z = j*20;
						circle.rotation.x = Math.PI * - 0.5;

						boxGeometry = new THREE.BoxBufferGeometry( tunnelLenght+10, 12, 1);
						const plankTexture1 = new THREE.TextureLoader(loadingManager).load( 'textures/plank.jpg' );
						const plankTexture2 = new THREE.TextureLoader(loadingManager).load( 'textures/plank.jpg' );
						plankTexture2.wrapS = THREE.RepeatWrapping;
						plankTexture2.wrapT = THREE.RepeatWrapping;
						plankTexture2.repeat.set( 0.25, 0.25 );
						const plankTexture3 = new THREE.TextureLoader(loadingManager).load( 'textures/plank.jpg' );
						plankTexture3.wrapS = THREE.RepeatWrapping;
						plankTexture3.wrapT = THREE.RepeatWrapping;
						plankTexture3.repeat.set( 1, 0.1 );												
						boxMaterial = 
							[
								new THREE.MeshStandardMaterial({map: plankTexture2, side: THREE.DoubleSide}), // RIGHT SIDE
								new THREE.MeshStandardMaterial({map: plankTexture3, side: THREE.DoubleSide}), // LEFT SIDE
								new THREE.MeshStandardMaterial({map: plankTexture3, side: THREE.DoubleSide}), // TOP SIDE
								new THREE.MeshStandardMaterial({map: plankTexture2, side: THREE.DoubleSide}), // BOTTOM SIDE
								new THREE.MeshStandardMaterial({map: plankTexture1, side: THREE.DoubleSide}), // FRONT SIDE
								new THREE.MeshStandardMaterial({map: plankTexture1, side: THREE.DoubleSide}) // BACK SIDE
							];
						var plank = new THREE.Mesh( boxGeometry, boxMaterial);

						plank.position.x = i*20;
						plank.position.y = 13.5;
						plank.position.z = j*20+2;
						plank.rotateX(Math.PI*3/2);
						
						scene.add( plank );	

						plank = new THREE.Mesh( boxGeometry, boxMaterial);

						plank.position.x = i*20+28;
						plank.position.y = 7.1;
						plank.position.z = j*20+10;
						plank.rotateY(Math.PI*3/2);
						plank.rotateX(Math.PI - Math.PI*1/9);

						scene.add( plank );							
							
						const collisionBox1 = new THREE.Box3();
						collisionBox1.setFromObject(cylinder);

						const collisionBox2 = new THREE.Box3();
						collisionBox2.setFromObject(plank);

						scene.add( circle );
						scene.add( torus );
						scene.add( cylinder );
						scene.add( cylinder2 );
						objects.push(collisionBox1);
						objects.push(collisionBox2);
						}

						else if (coordinates[j] === 40) {
							const scale = 2;
							const boxGeometry = new THREE.BoxBufferGeometry( scale, scale, scale)
							const red_texture = new THREE.TextureLoader(loadingManager).load( 'textures/magic_cube/red_cube.jpeg' );
							const orange_texture = new THREE.TextureLoader(loadingManager).load( 'textures/magic_cube/orange_cube.jpeg' );
							const blue_texture = new THREE.TextureLoader(loadingManager).load( 'textures/magic_cube/blue_cube.jpeg' );
							const white_texture = new THREE.TextureLoader(loadingManager).load( 'textures/magic_cube/white_cube.jpeg' );
							const green_texture = new THREE.TextureLoader(loadingManager).load( 'textures/magic_cube/green_cube.jpeg' );
							const yellow_texture = new THREE.TextureLoader(loadingManager).load( 'textures/magic_cube/yellow_cube.jpeg' );
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: red_texture}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: orange_texture}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: blue_texture}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: white_texture}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: green_texture}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: yellow_texture}) // BACK SIDE
								];

							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20-10;
							box1.position.y = 2.9;
							box1.position.z = j*20+3;
							box1.rotateY(Math.PI/6)

							scene.add(box1);
						}	

						else if (coordinates[j] === 41) {
							const scale = 3.2;
							const x = -12;
							const z = -8;
							const boxGeometry = new THREE.BoxBufferGeometry( scale, scale, scale)
							const clownBoxTexture = new THREE.TextureLoader(loadingManager).load( 'textures/clown_box.jpg' );
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: clownBoxTexture}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: clownBoxTexture}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: clownBoxTexture}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: clownBoxTexture}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: clownBoxTexture}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: clownBoxTexture}) // BACK SIDE
								];

							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20+x;
							box1.position.y = scale*0.9+1;
							box1.position.z = j*20+z;

							var cylinderGeometry = new THREE.CylinderBufferGeometry( 0.1, 0.1, 1.75, 12)
							var cylinderMaterial = new THREE.MeshStandardMaterial( {  color : 0x43464B, side: THREE.DoubleSide});							
							var cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );

							cylinder.position.x = i*20+1.75+x;
							cylinder.position.y = 4;
							cylinder.position.z = j*20+z;
							cylinder.rotateX(Math.PI / 4);
							cylinder.rotateZ(Math.PI/2);

							//

							cylinderGeometry = new THREE.CylinderBufferGeometry( 0.1, 0.1, 1, 12)
							cylinderMaterial = new THREE.MeshStandardMaterial( {  color : 0x43464B, side: THREE.DoubleSide});							
							const cylinder2 = new THREE.Mesh( cylinderGeometry, cylinderMaterial );

							cylinder2.position.x = i*20+2.55+x;
							cylinder2.position.y = 4.5;
							cylinder2.position.z = j*20+z;
							cylinder2.rotateY(Math.PI/2);

							//							

							const woodTexture = new THREE.TextureLoader(loadingManager).load( 'textures/plank.jpg' );
							cylinderGeometry = new THREE.CylinderBufferGeometry( 0.2, 0.2, 1, 12)
							cylinderMaterial = new THREE.MeshStandardMaterial( {  map : woodTexture, side: THREE.DoubleSide});							
							const cylinder3 = new THREE.Mesh( cylinderGeometry, cylinderMaterial );

							cylinder3.position.x = i*20+3+x;
							cylinder3.position.y = 5;
							cylinder3.position.z = j*20+z;
							cylinder3.rotateX(Math.PI/2);
							cylinder3.rotateZ(Math.PI/2);


							scene.add(box1);
							scene.add(cylinder);
							scene.add(cylinder2);
							scene.add(cylinder3);
						}							

						else if (coordinates[j] === 42) {
							const mattressLoader = new THREE.OBJLoader(loadingManager);
							let mattress;
							// load a resource
							mattressLoader.load(
								// resource URL
								'models/mattress/mattress.obj',
								// called when resource is loaded
								function ( mattress ) {
									mattress.position.x = i*20-19.8;
									mattress.position.y = 4.35;
									mattress.position.z = j*20-648.8;		

									mattress.scale.x = 0.18;
									mattress.scale.y = 0.10;
									mattress.scale.z = 0.18;
									mattress.rotateX(Math.PI)
									mattress.rotateY(Math.PI)	

									mattress.traverse( function ( child ) {

									if ( child instanceof THREE.Mesh ) {
										const mattressTexture = new THREE.TextureLoader(loadingManager).load( 'models/mattress/mattressTexture.jpg' );			
										child.material = new THREE.MeshStandardMaterial( {map: mattressTexture, side: THREE.DoubleSide} )
										}
									} );
									scene.add( mattress );
								}
							);
						}

						else if (coordinates[j] === 43) {
							const garbageCanLoader = new THREE.OBJLoader(loadingManager);
							let garbageCan;
							// load a resource
							garbageCanLoader.load(
								// resource URL
								'models/garbage_can/garbage_can.obj',
								// called when resource is loaded
								function ( garbageCan ) {
									garbageCan.position.x = i*20;
									garbageCan.position.y = 4.5;
									garbageCan.position.z = j*20-465.5;		
									garbageCan.rotateX(Math.PI/2);
									garbageCan.rotateZ(-Math.PI/1.6)

									garbageCan.scale.x = 0.05;
									garbageCan.scale.y = 0.05;
									garbageCan.scale.z = 0.05;

									garbageCan.traverse( function ( child ) {

									if ( child instanceof THREE.Mesh ) {
										const garbageCanTexture = new THREE.TextureLoader(loadingManager).load( 'models/garbage_can/garbage_can.png' );			
										child.material = new THREE.MeshStandardMaterial( {map: garbageCanTexture, side: THREE.DoubleSide} )
										}
									} );
									scene.add( garbageCan );
								}
							);
						}

						else if (coordinates[j] === 30) {
							const flashLightColor = 0x1F1F1F;

							flashLightBody = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 6.5, 12), new THREE.MeshBasicMaterial({color:flashLightColor}));
							flashLightBody.position.x = i*20;
							flashLightBody.position.y = 2.2;
							flashLightBody.position.z = j*20;
							flashLightBody.rotateX(Math.PI/2);
							flashLightBody.rotateZ(Math.PI-Math.PI*3/10)

							flashLightLamp = new THREE.Mesh(new THREE.CylinderGeometry(2, 1, 2, 12), new THREE.MeshBasicMaterial({color:flashLightColor}));
							flashLightLamp.position.x = i*20-3.435;
							flashLightLamp.position.y = 2.2;
							flashLightLamp.position.z = j*20-2.525;
							flashLightLamp.rotateX(Math.PI/2)
							flashLightLamp.rotateZ(Math.PI-Math.PI*3/10)	

							spotLight1 = new THREE.SpotLight(0xcccccc, 0.5, 150);
							spotLight1.power = 3.65;
							spotLight1.angle = 0.55;
							spotLight1.decay = 2;
							spotLight1.penumbra = 0.1;
							spotLight1.distance = 200;
							spotLight1.castShadow = true;

							spotLight2 = new THREE.SpotLight(0xcccccc, 0.5, 150);
							spotLight2.power = 1.65;
							spotLight2.angle = 0.65;
							spotLight2.decay = 2;
							spotLight2.penumbra = 0.1;
							spotLight2.distance = 200;
							spotLight2.castShadow = true;

							const texture = new THREE.TextureLoader(loadingManager).load( 'textures/flashLightLamp.png' );
							flashLightCircle = new THREE.Mesh( new THREE.CircleBufferGeometry( 1.75, 12 ), new THREE.MeshBasicMaterial( { map: texture, side: THREE.DoubleSide } ) );

							flashLightCircle.position.x = i*20-4.235;
							flashLightCircle.position.y = 2.2;
							flashLightCircle.position.z = j*20-3.225;
							flashLightCircle.rotateY(Math.PI*3/10)								

							flashLightLamp.add(spotLight1);
							flashLightLamp.add(spotLight2);
							scene.add(flashLightBody);
							scene.add(flashLightLamp);
							scene.add(flashLightCircle);
						}

						else if (coordinates[j] === 95) {
							const boxGeometry = new THREE.BoxBufferGeometry( 64, 54, 3)
							const wall_texture = new THREE.TextureLoader(loadingManager).load( 'textures/oldGate.jpg' );
							wall_texture.wrapS = THREE.RepeatWrapping;
							wall_texture.wrapT = THREE.RepeatWrapping;
							wall_texture.repeat.set( 2, 1 );
							const boxMaterial = 
								[
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // RIGHT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // LEFT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // TOP SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // BOTTOM SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}), // FRONT SIDE
									new THREE.MeshStandardMaterial({map: wall_texture, side: THREE.DoubleSide}) // BACK SIDE
								];

							const box1 = new THREE.Mesh( boxGeometry,  boxMaterial);

							box1.position.x = i*20;
							box1.position.y = 28;
							box1.position.z = j*20;
							box1.rotateY(Math.PI/2)
							
							const collisionBox = new THREE.Box3();
							collisionBox.setFromObject(box1);

							const box = new THREE.Mesh( boxGeometry,  boxMaterial);

							scene.add( box1 );	
							objects.push( collisionBox );							
						}

						else if (coordinates[j] === 99) {
							camera.position.set(i*20, 3, 20*j)
						}																			
 
					}
				}

				// rain

				rainCount=900;
				rainGeo = new THREE.Geometry();
				for(let i=0;i<rainCount;i++) {
					rainDrop = new THREE.Vector3(
					Math.random() * 400 -200,
					Math.random() * 500 - 250,
					Math.random() * 400 - 200
					);
					rainDrop.velocity = {};
					rainDrop.velocity = 0;
					rainGeo.vertices.push(rainDrop);
				}
				const rainMaterial = new THREE.PointsMaterial({
					color: 0xaaaaaa,
					size: 0.13,
					transparent: true
				});
				rain = new THREE.Points(rainGeo,rainMaterial);
				scene.add(rain);

				//
				inicialPapersLenght = papers.length;
				pages.innerHTML = collectPages + "/" + inicialPapersLenght;

				//slenderman

				const SlenderLoader = new THREE.OBJLoader(loadingManager);

				// load a resource
				SlenderLoader.load(
					// resource URL
					'models/slenderman/SM Model.obj',
					// called when resource is loaded
					function ( slenderMan ) {
						slenderMan.position.x = Math.floor(Math.random() * 400); 
						slenderMan.position.y = 0;
						slenderMan.position.z = Math.floor(Math.random() * 400); // come√ßar do fundo de forma randomica
						slenderMan.scale.x = 11;
            			slenderMan.scale.y = 11;
            			slenderMan.scale.z = 11;
						slenderMan.rotateY(Math.PI*11/12) // rever
						slenderMan.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {
							const slenderTexture = new THREE.TextureLoader(loadingManager).load( 'models/slenderman/slenderman_color.png' );			
							child.material = new THREE.MeshStandardMaterial( {map: slenderTexture, metalness: 0.95, fog: true} )
							}
						} );
						
						scene.add( slenderMan );
						slenders.push(slenderMan);
					}
				);

				// flaslight

				flashLight = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 6.5, 12), new THREE.MeshBasicMaterial({color:0x1F1F1F}));
				flashLight.rotateX(Math.PI/2);
				flashLight.position.set(2,-3,0)

				spotLight1 = new THREE.SpotLight(0xcccccc, 0.5, 150);
				spotLight1.power = 3.65;
				spotLight1.angle = 0.55;
				spotLight1.decay = 2;
				spotLight1.penumbra = 0.1;
				spotLight1.distance = 200;
				spotLight1.castShadow = true;
				spotLight1.rotateX(Math.PI/2);

				spotLight2 = new THREE.SpotLight(0xcccccc, 0.5, 150);
				spotLight2.power = 1.65;
				spotLight2.angle = 0.65;
				spotLight2.decay = 2;
				spotLight2.penumbra = 0.1;
				spotLight2.distance = 200;
				spotLight2.castShadow = true;
				spotLight2.rotateX(Math.PI/2);

				spotLight3 = new THREE.SpotLight(0xffffff, 0.5, 150);
				spotLight3.power = 5;
				spotLight3.angle = 0.40;
				spotLight3.decay = 6;
				spotLight3.penumbra = 1;
				spotLight3.distance = 200;
				spotLight3.castShadow = true;
				spotLight3.rotateX(Math.PI/2);

				spotLight4 = new THREE.SpotLight(0xcccccc, 0.5, 150);
				spotLight4.power = 2.65;
				spotLight4.angle = 0.1;
				spotLight4.decay = 6;
				spotLight4.penumbra = 0.1;
				spotLight4.distance = 200;
				spotLight4.castShadow = true;
				spotLight4.rotateX(Math.PI/2);											

				flashLight.add(spotLight1);
				flashLight.add(spotLight1.target);				
				flashLight.add(spotLight2);
				flashLight.add(spotLight2.target);
				flashLight.add(spotLight3);
				flashLight.add(spotLight3.target);						
				flashLight.add(spotLight4);
				flashLight.add(spotLight4.target);

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				
				// moon

				const height = 2.2;
				const moonTexture = new THREE.TextureLoader(loadingManager).load( 'textures/moon.png' );		
				const scale = 4;

				var geometry = new THREE.CircleBufferGeometry( 4 + scale, 16 );
				var material = new THREE.MeshBasicMaterial( { map: moonTexture, side: THREE.DoubleSide} );
				const moon = new THREE.Mesh( geometry, material );

				moon.position.set(800, 350, 560);
				moon.rotateX(Math.PI/2)

				scene.add( moon );				
				// postprocessing

				composer = new THREE.EffectComposer( renderer );
				composer.addPass( new THREE.RenderPass( scene, camera ) );

				glitchPass = new THREE.GlitchPass();
				composer.addPass( glitchPass );	

				container.append(composer.domElement);
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				composer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				// This block runs while resources are loading.
				if( RESOURCES_LOADED == false ){
					requestAnimationFrame(animate);					
					composer.render(loadingScreen.scene, loadingScreen.camera);
					return;
				}

				requestAnimationFrame( animate );

				const time = performance.now();

				rainGeo.vertices.forEach(p => {
					p.velocity -= 0.1 + Math.random() * 0.1;
					p.y += p.velocity;
					if (p.y < -200) {
						p.y = 200;
						p.velocity = 0;
					}
				});
				rainGeo.verticesNeedUpdate = true;
				rain.rotation.y +=0.002;

				controls.update();

				var vector = new THREE.Vector3(controls.mouse.x, controls.mouse.y, 1);
				vector.unproject(camera);

				var raycaster = new THREE.Raycaster( controls.fpsBody.position, vector.sub(controls.fpsBody.position).normalize() );

				rain.position.x = camera.position.x;
				rain.position.z = camera.position.z;

				for(var i = 0; i < water.length; i++) {
					var aux = raycaster.ray.origin.clone();
					aux.y = 0; // rever						
					if ( raycaster.ray.origin.distanceTo(water[i].position) <= 35) {							
						onWater = true;
						break;
					} else {
						onWater = false;
					}
				}

				if (onWater) {
					moveSpeed = baseMoveSpeed*6;
					flashLight.rotation.x = Math.PI/2;
				}
				else if (run && stamina > 0.35) {
					moveSpeed = baseMoveSpeed*0.55;
					stamina -= 0.65;
					if (stamina > 20) {
						flashLight.rotation.x = Math.PI/4;											
					} 
				} else {
					moveSpeed = baseMoveSpeed;
					flashLight.rotation.x = Math.PI/2;
					if(stamina <= 99.3) stamina += 0.07;
				}

				// Prevent the camera/player from falling out of the 'world'
				if ( controls.fpsBody.position.y < 18 ) {
					velocity.y = 0;
					controls.fpsBody.position.y = 18;
				}					

				for(var i = 0; i < objects.length; i++) {
					if ( raycaster.ray.intersectsBox( objects[i] ) === true) { 
						velocity.x = 0;
						velocity.z = 0;
						controls.fpsBody.position.x = origem.x;
						controls.fpsBody.position.y = origem.y;
						controls.fpsBody.position.z = origem.z;
					}
				}

				if(lanternPicked === false)	{
					if(interact === true && raycaster.ray.origin.distanceTo(flashLightBody.position) <= 30) {
						console.log('Pegou')
						
						AudioLoader.load( 'sounds/flashLightClickSound.wav', function( buffer ) {
							flashLightClickSound.setBuffer( buffer );
							flashLightClickSound.setLoop( false);
							flashLightClickSound.setVolume( 0.5 );
							flashLightClickSound.play();
							});							
						camera.add(flashLight);
						scene.remove(flashLightBody);
						scene.remove(flashLightLamp);
						scene.remove(flashLightCircle);
						lanternPicked = true;
					}
				}

				for(var i = 0; i < papers.length; i++) {
					var aux = raycaster.ray.origin.clone();
					aux.y = 10; // rever
					if ( aux.distanceTo(papers[i].position) <= 15 && interact === true) {
						scene.remove(papers[i]);
						papers.splice(papers.indexOf(papers[i]), 1);
													
						if(pageFlipSound.isPlaying === false)
							AudioLoader.load( 'sounds/page_flip.mp3', function( buffer ) {
								pageFlipSound.setBuffer( buffer );
								pageFlipSound.setLoop( false );
								pageFlipSound.setVolume( 0.4 );
								pageFlipSound.play();
							});
						collectPages += 1;
						slenderSpeed += 0.001;
						pages.innerHTML = collectPages + "/" + inicialPapersLenght;
					}
				}

				if ( raycaster.ray.origin.distanceTo(slenders[0].position) < 110) { 

					spotLight1.power = Math.floor(Math.random() * 6);
					spotLight2.power = Math.floor(Math.random() * 5);
					spotLight3.power = Math.floor(Math.random() * 10);
					spotLight4.power = Math.floor(Math.random() * 9);					

					if (raycaster.ray.origin.distanceTo(slenders[0].position) <  0) { //50
					
						camera.target = slenders[0];
						glitchPass.goWild = true;
						
						if(slenderStaticSound.isPlaying === false)
						AudioLoader.load( 'sounds/slender_static.mp3', function( buffer ) {
							slenderStaticSound.setBuffer( buffer );
							slenderStaticSound.setLoop( false );
							slenderStaticSound.setVolume( 0.3 );
							slenderStaticSound.play();
							document.removeEventListener('keydown', onKeyDown);
							setTimeout(() => {  open(location, '_self').close(); }, 7500);
						});
					}
				} else {
					spotLight1.power = 3.65;
					spotLight2.power = 1.65;
					spotLight3.power = 5;
					spotLight4.power = 2.65;						
				}

				origem = raycaster.ray.origin.clone();
				origem.y -= 10;	

				if(moveBackward || moveForward || moveLeft || moveRight) {
					if(stepSound.isPlaying === false) {
					AudioLoader.load( 'sounds/step' + Math.floor(Math.random() * 2) + '.mp3', function( buffer ) {
						stepSound.setBuffer( buffer );
						stepSound.setLoop( false);
						stepSound.setVolume( 0.6 );
						stepSound.play();
						});
					}
				}

				if(papers.length <= 0) {
					gameover.style.visibility = 'visible';						
					slenderSpeed = 0.02;
				};

				// slenderMan movimentation
				if(lanternPicked) {
					slenders[0].rotation.y = Math.atan2(( camera.position.z - slenders[0].position.z ) , ( camera.position.x - slenders[0].position.x ));
					slenders[0].position.lerp(camera.position, slenderSpeed)
				}
				if (slenders[0].position. y > 1) slenders[0].position.y = 1;
				//

				prevTime = time;
				//console.log(raycaster.ray.origin)
				composer.render( scene, camera);
			}

		</script>
	</body>
</html>
